<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Content Negotiation by Profile</title>
  <link rel="stylesheet" type="text/css" href="extra.css">
</head>
<body class="h-entry" id="respecDocument">
  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      This document describes how Internet clients may negotiate for content provided by servers according to
      <em>profiles</em>. This is distinct from negotiating by Media Type or Language: the <em>profile</em> is expected
      to specify the content of information returned, which may be a subset of the information the responding server has about the requested resource, and may be structured in a specific way to meet interoperability requirements of a community of practice.
    </p>
  </section>
  <section id="sotd">
    <!-- The "Status of This Document" section is generated by config.js -->
    <section id="FamilyOfDocs">
      <h3>Overview of DXWG documents on profiles</h3>
      <p>
        This document is one within a set of documents on profiles, edited by the W3C Dataset Exchange Working Group (DXWG).
	      Some of the documents are general whereas others are technology-specific:
      </p>
      <ul>
        <li>[[PROF]] an RDF vocabulary that describes profiles and related resources</li>
        <li><strong>[PROF-CONNEG] this document, specific guidance on how to negotiate for Internet resource content using profiles</strong></li>
        <li>[[PROF-IETF]] an <a href="http://www.ietf.org">IETF</a> <a href="http://www.ietf.org/standards/ids/">Internet-Draft</a> defining HTTP Headers for HTTP content negotiation by profile</li>
        <li>It is also planned to provide [[PROF-GUIDANCE]] as general recommendations and guidance on profiling.</li>
      </ul>
    </section>
  </section>
  <section id="introduction" class="informative">
    <h2>Introduction</h2>
    <p>
      Content delivered by dereferencing Internet identifiers can be negotiated for in different
      ways. When using the HTTP protocol [[RFC7230]], a client may set one or more headers:
    </p>
    <ul>
      <li>an <code>Accept</code> header specifying preferred Media Types which the server may or may not supply</li>
      <li>an <code>Accept-Encoding</code> header to request that a specific content encoding system be used</li>
      <li>an <code>Accept-Language</code> header to indicate a preferred language</li>
    </ul>
    <p>
      However, clients have not had a
      defined way to negotiate for content based on its adherence to an information model - a standard, a specification or
      a <a>profile</a> - and this document describes how this functionality can be delivered.
    </p>
    <p>
      When online information about a resource adheres to one or more profiles, methods described here allow
      clients to list those profiles and request content according to one or more of them in order of preference.
      For example, a catalog may offer a dataset description using alternative representations using [[VOID]],
      [[VOCAB-DATA-CUBE]] and [[VOCAB-DCAT]]. Furthermore, the [[VOCAB-DCAT]] representation might conform to the
      [[DCAT-AP]] profile, the [[GeoDCAT-AP]] profile and also an organisation specific profile "MyOrgDCATProfile"
      which constrains various elements. These profiles may be related - for example "MyOrgDCATProfile" may be a
      further profile of [[GeoDCAT-AP]]. A request for the information about this dataset description resource may
      ask for the list of profiles available, or it may ask specifically for a response adhering to, for example
      [[GeoDCAT-AP]]. When no profile or an unsupported profile is requested, a server returns default content,
      that is, content conforming to the default profile supported by the server.
    </p>
    <p class="issue" data-number="990">
        Where documents contain data specifications (specifying requirements for certain types of data) in addition to other content, such as recommendations, annotations, usage notes) then this can be accomodated by publishing explicit identifiers for each section that represents a data specification that can be conformed to. All such specifications can be regarded as profiles, and communities may choose to reference the document as a profile provided that it defines the means to determine conformance to the document as a whole.
    </p>
    <p>
      When selecting a content negotiation mechanism, an Internet client may use the HTTP protocol but it may also use
      other methods for providing instructions to a server,
      such as URI Query String Arguments (<abbr title="Query String Arguments">QSAs</abbr>).
      QSAs are
      established as useful for humans and machines for situations where negotiation via HTTP is not practical, such
      as when manually entering requests into web browsers. This document also provides guidance for both HTTP and non-HTTP methods
      of content negotiation and ensures they all adhere to a single functional specification, ensuring their functional equivalency.
    </p>
    <!--
    <p>
      Guidance for the creation of <a>profile</a>s is provided in the [[PROF-GUIDANCE]] document created
      by the Dataset Exchange Working Group (DXWG).
    </p>
    -->
    <p>
      Describing the parts of profiles and their relation to other profiles is the function of the Profiles Vocabulary
      [[PROF]], also produced by the DXWG.
    </p>
  </section>
  <section id="conformance">
    <p>
      For the purpose of compliance, the normative sections of this document are
      <a href="#definitions">Section 3</a>,
      <a href="#abstractmodel">Section 6</a>,
      <a href="#realizations">Section 7</a> and
      <a href="#testsuites">Section 8</a>.
    </p>
    <p class="note">Specifications and Profiles embody their own notions of conformance, which are out of scope for this specification.</p>
    <section id="conformance-profiles">
      <h3>Profiles for Conformance</h3>
      <p>
        This specification includes several <a>profiles</a> of it that may be conformed to by systems claiming to implement a form of this specification.
        These profiles, given in the table below, are identified by their URIs and conformance to them by Internet resources should be indicated as per this document (use of
        <code>Content-Profile</code> HTTP header).
      </p>
      <p>
        The namespace prefix for these profiles used in <a href="#fig-table-profiles"></a> is:
      </p>
      <ul>
        <li><code>cnpr</code> &rarr; <code>http://www.w3.org/ns/dx/conneg/profile/</code></li>
      </ul>
      <figure id="fig-table-profiles">
        <table>
          <thead>
          <tr>
            <th>URI</th>
            <th>Name</th>
            <th>Description</th>
            <th>Usage Note</th>
          </tr>
          </thead>
          <tbody>
          <tr>
            <td><code><a href="http://www.w3.org/ns/dx/conneg/profile/abstract">cnpr:abstract</a></code></td>
            <td>Abstract Model</td>
            <td>For conformance with the model presented in <a href="#abstractmodel"></a>.</td>
            <td>Not to be used if a resource also conforms to a more concrete profile (all of the others)</td>
          </tr>
          <tr>
            <td><code><a href="http://www.w3.org/ns/dx/conneg/profile/http">cnpr:http</a></code></td>
            <td>HTTP Realization</td>
            <td>For conformance with the realization presented in <a href="#http"></a>.</td>
            <td>To be used if a resource conforms to the HTTP Realization</td>
          </tr>
          <tr>
            <td><code><span style="white-space: nowrap"><a href="http://www.w3.org/ns/dx/conneg/profile/qsa">cnpr:qsa</a></span></code></td>
            <td>QSA Realization</td>
            <td>For conformance with the realization presented in <a href="#qsa"></a>.</td>
            <td>
              To be used if a resource conforms to the QSA Realization using the Query String Arguments <code>_profile</code> and <code>_mediatype</code> as per the recommendations
              in <a href="#qsa"></a>.
            </td>
          </tr>
          <tr>
            <td><code><span style="white-space: nowrap"><a href="http://www.w3.org/ns/dx/conneg/profile/qsa-alt">cnpr:qsa-alt</a></span></code></td>
            <td>QSA Alternate Keywords Realization</td>
            <td>For conformance with the realization presented in <a href="#qsa"></a>.</td>
            <td>
              To be used if a resource conforms to the QSA Realization but uses alternate keywords for the Query String Arguments <code>_profile</code> and
              <code>_mediatype</code>, as allowed by the recommendations in <a href="#qsa"></a>.
            </td>
          </tr>
          <tr>
            <td><code><span style="white-space: nowrap"><a href="http://www.w3.org/ns/dx/conneg/profile/rrd">cp:rrd</a></span></code></td>
            <td>Resource Representation Description</td>
            <td>For conformance with <a href="#getresourcebyprofile"></a>.</td>
            <td>
              To be used if a resource representation is able to indicate which profile(s) it conforms to, in its appropriate realization, as per the abstract specification in
              <a href="#getresourcebyprofile"></a>.
            </td>
          </tr>
          </tbody>
        </table>
        <figcaption>
          Profiles of this <em>Content Negotiation by Profile</em> specification to be used by resources and systems to indicate conformance to one or more forms
          of it.
        </figcaption>
      </figure>
      <p>
        The namespace used for the above profiles, <code>http://www.w3.org/ns/dx/conneg/profile/</code>, is part of the Dataset Exchange Working Group's reserved W3C namespace,
        <code>http://www.w3.org/ns/dx/</code>, which is provisioned for all namespace requirements to do with issues addressed by that Working Group. The <code>/profile/</code> path segment
        indicates a register of profile objects which currently contains just the 5 instances above from <a href="#fig-table-profiles"></a>.
      </p>
      <p>
        If a system wishes to show conformance to this specification, conformance to at least one of the profiles listed in <a href="#fig-table-profiles"></a> MUST be indicated.
      </p>
      <div class="note">
        This section's identifications of <a>profiles</a> of this <a>specification</a> exemplifies <em>functional</em> profiles which profile a functional specification, rather than a
        data profile which profiles a data specification. This specification describes how a system should behave and this section indicates different profiles of that behaviour, rather
        than content (data).
      </div>
    </section>
  </section>
  <section id="definitions">
    <h2>Definitions</h2>
    <dl>
      <dt><dfn data-lt="specification">specification</dfn></dt>
      <dd>
        <p>
          A basis for comparison; a reference point against which other things can be evaluated.
        </p>
        <p>
          <em>Source: DCMI Metadata Terms [[DCTERMS]]'s definition for a <a href="http://www.dublincore.org/specifications/dublin-core/dcmi-terms/#terms-Standard"><code>Standard</code></a>.</em>
        </p>
      </dd>
      <dt><dfn data-lt="data specification">data specification</dfn></dt>
      <dd>
        <p>
          A <a>specification</a>, with human- and/or machine-processable representations, that defines the content and structure of data used in a given context.
        </p>
        <p><em>Source: deliberations of the DXWG.</em></p>
      </dd>
      <dt><dfn data-lt="profile">data profile</dfn></dt>
      <dd>
        <p>
          A <a>data specification</a> that constrains, extends, combines, or provides guidance or explanation about the usage of other data specifications.
        </p>
        <p>
          This definition includes what are sometimes called "application profiles", "metadata application
          profiles", or "metadata profiles". In this document, these, and "data profiles", are all referred to as just "profiles".
        </p>
        <p><em>Source: deliberations of the DXWG.</em></p>
      </dd>
      <dt><dfn>client</dfn></dt>
      <dd>
        A program that establishes a connection to a <a>server</a> for the purpose of sending one or more HTTP requests. [[RFC7230]]
      </dd>
      <dt><dfn>server</dfn></dt>
      <dd>
        A program that accepts connections in order to service HTTP <a>requests</a> by sending HTTP <a>responses</a>. [[RFC7230]]
      </dd>
      <dt><dfn>resource</dfn></dt>
      <dd>
        The entity that is identified by a URI. Familiar examples include an electronic
        document, an image, a source of information with a consistent purpose. [[RFC3986]]
      </dd>
      <dt><dfn>representation</dfn></dt>
      <dd>
        <p>
          An abstraction of the current or desired state of a thing in HTTP communications. [[RFC7230]]
        </p>
        <p>
          In this specification, <em>representations</em> are of <a>resources</a>.
        </p>
      </dd>
      <dt><dfn>metadata</dfn></dt>
      <dd>Information that is supplied about a resource. [[RFC3986]]</dd>
      <dt><dfn>request</dfn></dt>
      <dd>A message sent over the Internet, from a <em>client</em> to a <em>server</em>, for a information about a <em>resource</em>. [[RFC7230]]</dd>
      <dt><dfn>response</dfn></dt>
      <dd>A message sent over the Internet, from a <em>server</em> to a <em>client</em> answering a <em>request</em> for information about a <em>resource</em>. [[RFC7230]]</dd>
      <dt><dfn>token</dfn></dt>
      <dd>A short name identifying something, in the context of this document, a <a>profile</a>.</dd>
    </dl>
  </section>
  <section id="motivation" class="informative">
    <h2>Motivation</h2>
    <p>
      In many cases, there are several ways to describe a resource within the scope of a single Media Type.
      For instance, XML documents, while conforming to the <code>text/xml</code> Media Type, may adhere to one of
      several DTDs or XML Schemas. RDF documents, with a choice of Media Type serializations such as
      <code>text/turtle</code>, <code>application/rdf+xml</code> and others, have a large number of vocabularies
      (classes and properties) available to use for their content's information model. When a client initiates a request
      for an Internet resource, such as an HTTP GET to retrieve a resource or an HTTP PUT to create or replace a resource, the client and server must have a standardized way to exchange information on how the transmitted resource
      will be structured according to DTDs, XML Schema, vocabularies or other standards, specifications or
      <em>profiles</em>. When using non-HTTP content negotiation, various methods such as URIs with Query String
      Arguments have been implemented previously,
      such as the
      <abbr title="Open Archives Initiative - Protocol for Metadata Harvesting">OAI-PMH</abbr> [[OAI-PMH]] and
      <abbr title="Open Geospatial Consortium">OGC</abbr>'s
      <abbr title="Catalogue Service for the Web">CSW</abbr> [[CSW]] protocols.
    </p>
    <p>
      This document describes an abstract, functions-based, model for content negotiation by profile and gives both the
      HTTP header <em>realization</em> and also a recommended query string argument-based <em>realization</em> too. The query string
	   approach provides a "fall back" required by the
      <a href="https://www.w3.org/2017/dxwg/charter">Dataset Exchange Working Group's Charter</a> (Section 2.3). Other query string or REST-based <em>realizations</em>
      are considered possible but are not given here. In general, existing APIs that support specification of alternative
      profiles for resource representations may support this model too by implementing its functions.
    </p>
  </section>
  <section id="relatedwork" class="informative">
    <h2>Related Work</h2>
    <p>
      The standardization of the content-negotiation HTTP headers is the purview of the IETF. A first proposal
      for an <a href="https://profilenegotiation.github.io/I-D-Accept--Schema/I-D-accept-schema">Internet Draft
      for Negotiating Profiles in HTTP</a> [[PROF-IETF]] is available but has not yet been submitted to the IETF. The
      current version of the IETF draft (-00) is expected to be completely re-written in parallel work with this document and should
      not be seen as anything but work-in-progress.
    </p>
    <section id="related-http">
      <h3>Existing standards for transporting profile information in HTTP headers</h3>
      <h4>Using Accept/Content Type together with the profile parameter</h4>
      <p>The HTTP Accept and Content-Type header fields [[RFC7231]]
        allow a client to specify acceptable media types (<code>Accept</code>)
        and a server to indicate the media type of the payload (<code>Content-Type</code>).
        A media type registration can also specify an optional list of media type parameters.
        Some media type registrations (e. g. <code>application/ld+json</code>)
        have specified the use of a media type parameter named "profile"
        that could be used to signal the profile the payload of the message conforms to.</p>
      <pre id="eg-profile-and-accept" class="example nohighlight" aria-busy="false" aria-live="polite"
           title="Using the profile parameter in an Accept header together with the Accept-Profile header">
GET /resource/a HTTP/1.1
Accept: text/turtle;q=0.9;profile="urn:example:profile-1",
  text/turtle;q=0.7;profile="urn:example:profile-2"

HTTP/1.1 200 OK
Content-Type: text/turtle;profile="urn:example:profile-2"
  </pre>
      <p>During TPAC 2018 in Lyon, the DXWG had a longer discussion with the JSON-LD WG
    and it was concluded that the “profile” parameter in the <code>Accept</code> and <code>Content-Type</code>
    headers should be seen to convey profiles that are specific to the media-type,
    such as the JSON-LD profiles "expanded" (<code>http://www.w3.org/ns/json-ld#expanded</code>) or
    "flattened" (<code>http://www.w3.org/ns/json-ld#flattened</code>).
    In order to signal the use of media-type-independent profiles,
    the http header fields <code>Accept-Profile</code> and <code>Content-Profile</code> are to be used.</p>
      <h4>Using a Link-header with rel=”profile” (RFC 6906)</h4>
      <p>The HTTP Link header field [[RFC8288]] relates a web resource (Link Context)
    to a target resource (Link Target
    by specifying the relation between the two resources.
    One of the relation types is “profile” as defined in [[RFC6906]].
        [[RFC6906]] <a data-cite="RFC6906#section-3">defines a profile</a> as
        "additional semantics that can be used to process a resource representation […]
        that do not alter the basic media type semantics,"
        and specifically states that
        "creators and users of profiles MAY define and manage them in a way
        that allows them to be used across media types,"
        so that the "profile" relation seems like a suitable way
        to transport information about acceptable profiles (request) and payload profile (response).</p>
      <pre id="eg-link-header-with-profile" class="example nohighlight" aria-busy="false" aria-live="polite"
           title="Using a Link header with a profile parameter">
HEAD /resource/a HTTP/1.1
Accept: text/turtle;q=0.9,application/rdf+xml;q=0.5
Link: &lt;http://example.com/profile/x&gt;; rel="profile"

HTTP/1.1 200 OK
Content-type: text/turtle
Link: &lt;http://example.com/profile/x&gt;; rel="profile"
      </pre>
      <p>There is, however, no possibility to convey quality information (q-values) using the “profile” relation.</p>
      <h4>Using the Prefer/Preference-Applied header fields (RFC 7240)</h4>
      <p>The http <code>Prefer</code> and <code>Preference-Applied</code> header fields [[RFC7240]]
      can be used to convey information about profile preferences.
      A client could use the <code>Prefer</code> header to tell the server about
      its preference for a payload conforming to a specific profile.
      If the server sends a <code>Preference-Applied</code> header field in the response,
      the client will know that the preference was honoured.</p>
      <pre id="eg-prefer-header-with-profile" class="example nohighlight" aria-busy="false" aria-live="polite"
           title="Using a Prefer header with a profile parameter">
GET /resource/a HTTP/1.1
Accept: text/turtle
Prefer: profile="urn:example:schema"

HTTP/1.1 200 OK
Content-Type: text/turtle
Preference-Applied: profile="urn:example:schema"
      </pre>
      <p>This approach has two disadvantages.
      The first is - as with the <code>Link</code> header,
      that there is no possibility to work with q-values.
      The second one is that the only way for a server to state
      that it ignored the preference stated by the client
      is to omit sending a <code>Preference-Applied</code> header field.
      For the client - however - it is not clear
      if the <code>Preference-Applied</code> header is absent
      because the server did not honour the preference,
      or if it is because the server did not understand
      the <code>Prefer</code> header in the first place.
      This could be solved by making it mandatory to send a
      <code>Link: rel=profil</code> header when answering to a request
      with a <code>Prefer: profile=''</code> header in it.
      That solution requires that a client evaluates two different headers
      in order to find a response to its request for a specific profile,
      which would make client implementation more complicated.</p>
      <p class="issue" data-number="380">
        The Internet-Draft for the registration of
        <code>Accept-Profile</code> and <code>Content-Profile</code>
        is currently work-in progress.
        When that work is completed, the above text will be adjusted accordingly
        or deleted.
      </p>
      <p class="issue" data-number="382">
        Previous uses of <code>Accept-*</code> headers
        or other HTTP headers for this use
        will be listed and discussed here.
      </p>
    </section>
	  <section id="related-ark">
		  <h3>Archival Resource Key (ARK)</h3>
		  <p>ARK (Archival Resource Key) [[ARK]] is an identifier scheme
			for the persistent identification of information objects.
			ARK identifiers can contain an optional qualifier
			"that extends the base ARK in order to create a kind of service entry point
			into the object named by the NAA [sc. Name Assigning Authority]."
			Through a qualifier, any NMA (Name Mapping Authority, a service provider offering ARK resolution)
			can supply access to variants of that object.
			The set of qualifiers is open and any ARK NAA or NMA can invent its own.
			The ARK specification lists versions, languages and formats as examples of qualifiers (§2.5)
			and a profile name could be used as a qualifier
			to refer to a representation of an information object conforming to that specific profile.
			For example, the URI <a href="https://api.istex.fr/ark:/67375/6GQ-MLC8GRWC-5/">https://api.istex.fr/ark:/67375/6GQ-MLC8GRWC-5/</a>
      lists different XML encodings of metadata for the resource identified by the ARK <code>67375/6GQ-MLC8GRWC-5</code>,
      according to different XML vocabularies, including "MODS", the Library of Congress'
      <a href="https://www.loc.gov/standards/mods/">Metadata Object Description Schema</a>.
		  </p>
	  </section>
    <div class="issue" data-number="383"></div>
    <section id="related-altviews">
      <h3>Linked Data APIs</h3>
      <p>
        Several Linked Data API tools provide access to different representations of resources, identified by URI, via
        use of Query String Arguments (QSAs). Two examples are the
        <a href="http://epimorphics.github.io/elda/current/index.html">ELDA tool by Epimorphics</a>, an
        implementation of the <a href="https://github.com/UKGovLD/linked-data-api/blob/wiki/Specification.md">Linked
        Data API</a> specification created by the government of the United Kingdom, and the <a href="">pyLDAPI</a> Python
        Linked Data API implementation by <a href="https://www.csiro.au/">CSIRO</a>. Both of these tools allow the
        listing of <em>views</em> and <em>formats</em> available for a resource by dereferencing the URL created by
        adding the <abbr title='Query String Argument'>QSA</abbr> <code>_view=alternates</code> to the resource URI. The
        <em>view</em> named <em>alternates</em> is a special view available for all resources.
      </p>
      <p>
        What these tools call a <em>view</em> is analogous to a profile and a <em>format</em> to an HTTP Media Type.
      </p>
      <p>
        These APIs provide for direct access to resource representations, conforming to a particular view, in a
        particular format, or a default view/format if either is unspecified or invalid. For example, using pyLDAPI, the
        available views and formats for the address <a href="http://linked.data.gov.au/dataset/gnaf/address/GAACT714845933">GAACT714845933</a>
        can by seen by dereferencing <a href="http://linked.data.gov.au/dataset/gnaf/address/GAACT714845933?_view=alternates">http://linked.data.gov.au/dataset/gnaf/address/GAACT714845933<strong>?_view=alternates</strong></a>
        and the "ISO19160" <em>view</em> of that Address, listed by the Alternates View, and in the RDF Turtle
        <em>format</em>, is available at <a href="http://linked.data.gov.au/dataset/gnaf/address/GAACT714845933?_view=ISO19160&_format=text/turtle">http://linked.data.gov.au/dataset/gnaf/address/GAACT714845933<strong>?_view=ISO19160&amp;_format=text/turtle</strong></a>.
      </p>
    </section>
    <div class="issue" data-number="516"></div>
    <section id="related-oai-pmh">
      <h3>OAI-PMH</h3>
      <p>
        The Open Archives Initiative Protocol for Metadata Harvesting [[OAI-PMH]] "...provides an
        application-independent interoperability framework based on metadata harvesting." In doing this, OAI-PMH
        specifies Query String Argument-based "Protocol Requests and Responses" that allow clients of
        <em>Data Providers</em> to: retrieve the metadata formats available from a repository
        (<code>ListMetadataFormats</code>); retrieve metadata for an identified record (<code>GetRecord</code>),
	according to an identified metadata profile (<code>metadataPrefix</code>); perform a number of other repository interrogation tasks; and to
        harvest collections of record's metadata, filtered by parameters such as modified date.
      </p>
      <p>
        OAI-PMH requires that representations of all resources in a repository are available according to the same set
        of profiles. It is also entirely XML-based so that profiles, or "metadata formats" as they are called in OAI-PMH, must
        all be presented in XML and the content of an XML representation of a resource is presented within an XML
        envelope that always identifies the record, the profile, the OAI-PMH method used, the request time and other
        common metadata.
      </p>
    </section>
    <div class="issue" data-number="384"></div>
    <section id="related-csw">
      <h3>Catalogue Service for the Web (CSW)</h3>
      <p>
        [[CSW]] is the OGC standard used world-wide by the geospatial community to implement a machine-actionable interface
	to catalog services, providing access to metadata about datasets, geospatial services ([[WMS]], [[WFS]], etc.),
	as well as other types of resources. Besides supporting common functions such as free-text and faceted search, CSW supports the retrieval of metadata according to a given metadata schema and format, indicated respectively by using <code>outputSchema</code> and <code>outputFormat</code> query parameters. Commonly supported metadata schemas are [[DC11]], and [[ISO-19115]], and the default format is XML. A given CSW instance's supported metadata schemas and formats are described in the service "capabilities" -- a machine-readable description of the service interface, that is returned via a <code>GetCapabilities</code> request.
      </p>
      <p>
        Notably, CSW theoretically supports HTTP content negotiation for the metadata format, and the specification defines a conflict resolution mechanism for requests where this information is specified both via HTTP <code>Accept</code> headers and the <code>outputFormat</code> parameter (see Section 6.2 of the <a href="http://docs.opengeospatial.org/is/12-176r7/12-176r7.html">OGC CSW 3.0 specification - HTTP Protocol Binding</a>).
      </p>
    </section>
  </section>
  <section id="abstractmodel">
    <h2>Abstract Model</h2>
    <p>
      This section describes a conceptual, abstract, model for content negotiation by profile, independent of any
      realizations of it within specific environments.
    </p>
    <p>
      Realizations of this abstract model MUST implement its functions, but how they do this will be
      environment-specific.
    </p>
    <section id="abstractmodelcontext">
      <h3>Context</h3>
      <p>
        All content negotiation takes place between a <a>client</a> and a <a>server</a> over the Internet with the
        former requesting a representation of a <a>resource</a> or a <em>resource</em>'s <em>metadata</em> through a
        <a>request</a> and receiving it via a <a>response</a>. In some cases, a <em>server</em> may have to make a
        <em>request</em> of a <em>client</em> and receive a <em>response</em>.
      </p>
      <p>
        An Internet <em>resource</em> may have many aspects over which a <em>client</em>/<em>server</em> pair of
        agents might negotiate for content. These aspects are to be treated independently so content negotiation for a
        resource involving negotiation by profile and any other aspects of a resource will not affect
        each other. For this reason, other than a directive to maintain independence, no further discussion of
        negotiation by profile and the relations to other forms of negotiation are given. Specific realizations might
        require special handling of profile and other forms of negotiation.
      </p>
      <p>
        A <em>client</em> <em>request</em>ing the representation of a <em>resource</em> conforming to a <em>profile</em>
        MUST identify the <em>resource</em> by a Uniform Resource Identifier (URI) [[RFC3986]] and MUST
        identify a <em>profile</em> either by a URI or a <em>token</em> that unambiguously identifies the
        <em>profile</em> for the <em>server</em> within that <em>request</em>/<em>response</em> session.
      </p>
      <p>
        In this abstract model, we don't assume any specific details about <em>client</em>, <em>server</em>, <em>resource</em>,
        <em>metadata</em>, <em>request</em> or <em>response</em>.
      </p>
      <p>
        If a URI is used for profile identification, it is recommended that it be an HTTP
        URI that dereferences to a description of the profile. Other kinds or URIs, e. g. URNs <em>MAY</em> also be used however
        systems will need to provide means to describe such profiles for a given URN. When a token is used, the
        server is responsible for declaring the context within which the token may be mapped to a unique profile
        identifier, such as an HTTP namespace.
      </p>
    </section>
    <section id="requestsandresonses">
      <h3>Requests and Responses</h3>
      <p>
        There are two main types of <em>request</em> that a <em>client</em> might make of a <em>server</em> regarding
        content negotiation by profile. A <em>client</em> wishing to negotiate for content via a profile adhering to this
        specification MUST be able to implement these two request types.</p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <a>client</a> requests the list of URIs of <a>profile</a>s for which a <a>server</a> is able to deliver
          conformant <a>resource</a> <a>representations</a>
        </li>
        <li>
          <strong>get resource by profile</strong>
          <br />a <a>client</a> requests a <a>representation</a> of the requested <a>resource</a> represented conforming
          to a particular <a>profile</a>
        </li>
      </ol>
      <p>
        A <em>server</em> adhering to this specification MUST respond to each request with the following
        <em>response</em>s.
      </p>
      <ol>
        <li>
          <strong>list profiles</strong><br />
          a <a>server</a> responds to a <a>client</a> with the list of URIs of the <a>profiles</a> for which it is able
          to deliver conformant <a>resource</a> <a>representations</a>
        </li>
        <li>
          <strong>get resource by profile</strong><br />
          a <a>server</a> responds with either a specific <a>profile</a> for a <a>resource</a> conforming to a
          requested <a>profile</a> identified by the <a>client</a> or it responds with a default <a>profile</a>
        </li>
      </ol>
      <p>More detailed descriptions of these requests and their responses are given next.</p>
      <section id="listprofiles">
        <h4>list profiles</h4>
        <p>
          A <em>client</em> wishes to know for which <em>profile</em>s a <em>server</em> is able to deliver conformant
          representations of a <em>resource</em>. The content of the list can be known either before a <em>request</em> for a
          particular <em>resource</em> representation is made or it may only be known after an initial <em>request</em> for a
          <em>resource</em> representation is made.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MUST be either an independent request or part of another
          realization's request.
        </p>
        <p>
          The <strong>list profiles</strong> <em>request</em> MAY result in a <em>response</em> in one of a
          number of formats provided that the <em>profile</em>s representations of resources
          conform to are unambiguously identified either by URI or a <em>token</em> which MUST be mappable to a URI
          within one particular client/server session.
        </p>
        <p>
          A <em>server</em> MUST NOT list <em>profile</em>s that <em>resource</em> representations conform to if
          it is unable to deliver those representations when presented with a <strong>get resource by profile</strong>
          <em>request</em>.
        </p>
        <div class="issue" data-number="602"></div>
      </section>
      <section id="getresourcebyprofile">
        <h4>get resource by profile</h4>
        <p>
          The most basic <em>request</em> of content negotiation by profile is for a <em>client</em> to <em>request</em>
          a representation of a <em>resource</em> that is claimed to conform to a <em>profile</em>.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> <em>request</em> MUST
          identify the <em>profile</em> with either a URI or a token mapping unambiguously within a session to a URI.
        </p>
        <p>
          A <em>client</em> executing a <strong>get resource by profile</strong> MAY <em>request</em> a
          <em>resource</em> representation conforming to one of any number of <em>profile</em>s with its preference
          expressed in a some form of list ordering.
        </p>
        <p>
          The server should attempt to reply with a profile that best matches the client request. The order of
          preference a server <em>MUST</em> follow to determine a best matching profile is: an exact match, followed by
          anything that the profile profiles (a more general specification or profile), perhaps transitively.
        </p>
        <p>
          A <a>server</a> SHOULD set a <code>Content-Profile</code> header in HTTP <a>response</a> to the profile
          identifier (URI) that the Client requested, not the identifier of any narrower profile that is also applicable
          since the client might not understand the narrower profile identifier.
        </p>
        <pre id="eg-narrower-profile-response" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Get resource by profile, narrower profile response (HTTP realization)">
# a request for Resource a according to Profile x is made

GET /resource/a HTTP/1.1
Accept-Profile: http://example.org/profile/x
[more request headers]

---

# the server IS NOT able to respond with a representation
# of Resource a conforming to Profile x

# the server IS able to respond with a representation of
# Resource a according to Profile B which it knows is a
# profile of Profile x

# the server indicates the response conforms to Profile x,
# not Profile y so the client is assured of conformance

HTTP/1.1 200 OK
[other response headers]
Content-Profile: &lt;http://example.org/profile/x>
[more response headers]

[content according to Profile B and thus Profile A which it profiles]
          </pre>
        <p>
          When a resource is returned that conforms to two or more profiles not within a profile hierarchy
          (i.e. none of the multiple profiles the resource conforms to is a profiles of another), the server MUST
          indicate all profiles individually within the <code>Content-Profile</code> header as such:
        </p>
        <p>
          <code>Content-Profile: &lt;PROFILE_1>, &lt;PROFILE_2></code>
        </p>
        <p>
          For example, a response from a server that conforms to both [[?GeoDCAT-AP]] and also [[?statdcat-ap]], given
          that neither profiles the other and thus no single indication of conformance will suffice for both, (note they
          both do profile [[?DCAT-AP]], see the <a href="https://www.w3.org/TR/dx-prof/#eg-hierarchy">DCAT-AP Hierarchy
          example in [[PROF]]</a>), using profile URIs for [[?GeoDCAT-AP]] and [[?statdcat-ap]] could be:
        </p>
        <p>
          <code>Content-Profile: &lt;https://joinup.ec.europa.eu/release/geodcat-ap-v10>, &lt;https://joinup.ec.europa.eu/release/statdcat-ap/101></code>
        </p>
        <div class="issue" data-number="748"></div>
      </section>
    </section>
    <section id="altr">
      <h3>Alternate Representations Data Model</h3>
      <p>
        This data model, MUST be used for describing the representations of a resource that conform to different
        profiles.
      </p>
      <p>
        An graphical overview of this model is given in <a href="#fig-altr-model"></a>.
      </p>
      <figure id="fig-altr-model">
        <img src="altr.svg" alt="Alternate Profiles data model" style="width:60%" />
        <figcaption>
          A diagram of the Alternate Profiles data model implemented in OWL [[OWL2-OVERVIEW]].
        </figcaption>
      </figure>
      <p>
        Descriptions of alternate representations of resource according to different profiles MAY be presented according
        to modelling systems implementing this model, depending
        on what is deemed to be relevant to the application profile of this specification that they are created for. For
        example, the HTTP Application Profile (<a href="#http"></a>) is limited to text within the constrains of the
        HTTP specification's headers structure in [[RFC7230]] and thus syntactic communication of this data model in
        that environment must be implemented according to its constraints.
      </p>
      <p>
        Tools for testing the conformance of data instances to some implementations of this data model are given in
        <a href="#testsuites"></a>. Suggestions for concrete implementations of, and extensions to, this data model for
        use in expected situations are given in <a href="#altr-detail"></a>. Examples of suggested use as per the  are
        also given in Functional Profiles of this specification are also given in that appendix.
      </p>
    </section>
  </section>
  <section id="realizations">
    <h2>Realizations</h2>
    <p>
      This section describes <em>realizations</em> of the abstract model which are implementations of it in different
      environments.
    </p>
    <p>
      This document provides onw two <em>realizations</em> however it is expected that implementers of content
      negotiation by profile may implement further realizations in other environments.
    </p>
    <p class="note" title="Realization requirements">
      Implementers of Content Negotiation by Profile need not implement multiple realizations of the
      <a href="#abstractmodel">Abstract Model</a>. They need only implement the realizations relevant to them - either
      those defined in this document or new ones they define, however each realization MUST accord with the Abstract
      Model.
    </p>
    <section id="http">
      <h3>Hypertext Transfer Protocol Headers</h3>
      <p>
        A realization of the Abstract Model using Hypertext Transfer Protocol (HTTP) headers is presented here.
        This implementation is based on HTTP content negotiation and uses two new HTTP headers,
	      <code>Accept-Profile</code> and <code>Content-Profile</code>
	      that are to be defined in an upcoming Internet-Draft [[PROF-IETF]].
      </p>
      <p>
	      Although servers are free to implement negotiation as they see fit,
	      if the User Agent sends an <code>Accept-Profile</code> header,
	      they SHOULD consider representations not conforming to any of the listed profiles
	      as non-interpretable by the client.
	      This means that a representation that conforms to a listed profile,
	      but has a low preference score on other dimensions,
	      SHOULD be considered as more desired than
	      a representation with a higher preference score on other dimensions
	      but that does not conform to any listed profile.
	      If no <code>Accept-Profile</code> header preference is given,
	      the profile dimension SHOULD be ignored for negotiation purposes.
	      Nonetheless, in all cases,
	      the server's response SHOULD contain a <code>Content-Profile</code> header
	      listing the URIs of all profiles to which it knows the representation conforms.
      </p>
      <section id="listprofileshttp">
        <h3>list profiles</h3>
        <p>
          The preferred way to retrieve a list of profiles the server supports for a specific resource
	  is to issue a <code>GET</code> or <code>HEAD</code> request for that resource.
	  In either case, a server implementing
          content negotiation by profile SHOULD return an HTTP <code>Link</code> header containing information about the
          default representation of that resource and information about any alternate representations of that
          resource conforming to other profiles. The returned representation will be identified by <code>rel="self"</code>, other representations by
          <code>rel="alternate"</code>.
        </p>
        <p>As an example, consider the resource <code>http://example.org/resource/a</code> available
          in the Media Types <code>application/xml</code>, <code>text/html</code> and <code>text/turtle</code>.
          The <code>text/html</code> representation has
          no profile, whereas the <code>application/xml</code> and <code>text/turtle</code> representations are
          both available in the profiles <code>urn:example:profile:x</code> and <code>urn:example:profile:y</code>.
        </p>
        <p>
          Assuming that a request without an <code>Accept-Profile</code> header per default delivers content conforming to
          <code>urn:example:profile:x</code>, an HTTP request/response pair would look as per
          <a href="#eg-link-headers"></a>.
        </p>
        <pre id="eg-link-headers" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Server returns a Link header to indicate available profiles">
HEAD /resource/a HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Profile: urn:example:profile:x
Link:
  &lt;http://example.org/resource/a&gt;;
          rel="self";
          type="text/turtle";
          profile="urn:example:profile:x",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="text/turtle";
          profile="urn:example:profile:y",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="application/xml";
          profile="urn:example:profile:x",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="application/xml";
          profile="urn:example:profile:y",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="text/html"
[more response headers]
        </pre>
        <p>
          In <a href="#eg-link-headers"></a>, for each of the different Media Type / Profile combinations, the URI of
          the resource remains unchanged and it is the <code>Accept</code> and <code>Accept-Profile</code> headers for
          Media Type and Profile respectively that alter the returned response.
        </p>
        <p>
          A server MAY use <code>Content-Location</code> HTTP headers to indicate direct links to representations of the
          resource according to Media Type / Profile combinations and, if it does so, it may replace the unchanged URI
          in the Link header with those direct URIs, as per example <a href=""></a>.
        </p>
        <pre id="eg-link-headers-loc" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Server returns Link header with Content-Location URIs for some Profiles and Media Types">
HEAD /resource/a HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/resource/a.prof1.ttl
Content-Profile: &lt;urn:example:profile:x>
Link:
  <strong>&lt;http://example.org/resource/a.prof1.ttl&gt;;</strong>
          rel="self"; type="text/turtle";
          profile="urn:example:profile:x",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="text/turtle";
          profile="urn:example:profile:y",
  <strong>&lt;http://example.org/resource/a.prof1.xml&gt;;</strong>
          rel="alternate";
          type="application/xml";
          profile="urn:example:profile:x",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="application/xml";
          profile="urn:example:profile:y",
  &lt;http://example.org/resource/a&gt;;
          rel="alternate";
          type="text/html"
[more response headers]

[In the Link header, Content-Location URIs are only used as context
URIs for resources conforming to profile urn:example:profile:x]
        </pre>
        <div class="issue" data-number="290"></div>
        <p>
          The <code>Link</code> HTTP header used to communicate alternate profiles for a resource as per
          <a href="#eg-link-headers"></a> conforms to the Alternate Profiles Data Model
          (<a href="#altr"></a>) with the mapping given in <a href=""></a>
        </p>
        <figure id="fig-altr-link-header-mapping">
          <table>
            <tr>
              <th>Link Header Element</th><th>Alternate Reresentations Data Model Element</th>
            </tr>
            <tr>
              <td></td><td></td>
            </tr>
          </table>
          <figcaption>
            A mapping of the elements within an HTTP <code>Link</code> header communicating alternat representations
            information to the elements within the Alternate Profiles Data Model.
          </figcaption>
        </figure>
        <section id="listprofiles-tokens">
          <h3>Token mappings</h3>
          <p>
            If HTTP <em>server</em>s wish to allow <em>client</em>s to identify <em>profile</em>s via <em>token</em>,
            in addition to the the mandatory identification of <em>profile</em>s via via URI, the <em>server</em>s will
            need to provide a <em>token</em> / URI mapping via this <strong>list profiles</strong> function. In this
            HTTP realization, this may be implemented in a number of ways. The preferred way is to add "token"
            parameters to the HTTP Content-Profile and Link HTTP headers.
          </p>
          <pre id="eg-uri-token" class="example nohighlight" aria-busy="false" aria-live="polite"
               title="HTTP headers with profile URI / token mappings using 'token' parameters">
# The Profile with urn:example:profile:x is mapped to token px and URI
# and the Profile with URI http://example.org/profile/y is mapped to py

HEAD /resource/a HTTP/1.1
Accept: text/turtle
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Location: http://example.org/resource/a.profx.ttl
Content-Profile: &lt;urn:example:profile:x;token=px>
Link: &lt;http://example.org/resource/a.profx.ttl&gt;; rel="self"; type="text/turtle"; profile="urn:example:profile:x;token=px",
  &lt;http://example.org/resource/a.profy.ttl&gt;; rel="alternate"; type="text/turtle"; profile="http://example.org/profile/2;token=py",
  &lt;http://example.org/resource/a.profx.xml&gt;; rel="alternate"; type="application/xml"; profile="urn:example:profile:x;token=px",
  &lt;http://example.org/resource/a.profy.xml&gt;; rel="alternate"; type="application/xml"; profile="http://example.org/profile/2;token=py",
  &lt;http://example.org/resource/a.html&gt;; rel="alternate"; type="text/html"
[more response headers]
          </pre>
          <div class="issue" data-number="904"></div>
          <div class="note" title="Multiple ways of conveying URI / token mappings">
            <p>
              There are several methods that many be used to convey URI / token mappings including the recommended
              method described and exemplified above.
            </p>
            <h4>Option 1: token parameters (recommended)</h4>
            <p>
              "token" parameters are added to <code>Content-Profile</code> &amp; <code>Link profile=</code> HTT headers.<br />
              Pros: self-contained,flexible, explicit.<br />
              Cons: potential redundancy in URIs if many offered
            </p>
            <h4>Option 2: registered tokens</h4>
            <p>
              Tokens are registered in a global registry and servers may use them in place of a URI<br />
              <code>Content-profile: token1, &lt;URI2></code>
              Pros: compact<br />
              Cons: a global registry for profiles not manageable when many systems define profiles and such a registry
              limits other capabilities of profile description by forcing generic profiles
            </p>
            <h4>Option 3: allow namespace declarations</h4>
            <p>
              As per the use of CURIEs [[CURIE]] whose specification "...defines a generic, abbreviated syntax for
              expressing URIs.", within JSON-LD [[JSON-LD]], a token may be indicated for use in place of a URI within
              a namespacing context. In this method, key/value pairs of tokens/URIs are defined within an HTTP header
              such as <code>Content-Profile</code> like this:
            </p>
            <p>
              <code>Content-Profile: @:http://example.org/profiles/,@w3c:http://w3.org/knownprofiles#, :token1, w3c:token2</code>
            </p>
            <p>
              Where the first key/value pair of token/URI is key: &lt;nothing&gt;, value: http://example.org/profiles/
              and the second, is key: &lt;w3c&gt;, value:http://w3.org/knownprofiles#.
            </p>
            <p>
              Pros: compact, no registry requirement<br />
              Cons: clients have more parsing to do<br />
              Note: could easily be a JSON-LD payload<br />
              (alternative syntax using parameter ns2;ns=http://example.org/profiles/)
            </p>
            <h4>Option 4: namespace header</h4>
            <p>
              In this method, a new HTTP header could be introduced to specifically convey token/URI profile key/value
              pairs. If <code>Content-Profile-Namespaces</code> is to be the new HTTP header, then a <em>server</em> may
              respond to a request with the following pair of headers:
            </p>
            <p>
              <code>
                Content-Profile-Namespaces: :http://example.org/profiles/,w3c:http://w3.org/knownprofiles#<br />
                Content-Profile: :token1, w3c:token2
              </code>
            </p>
          </div>
        </section>
        <div class="issue" data-number="679"></div>
      </section>
      <section id="getresourcebyprofilehttp">
        <h3>get resource by profile</h3>
        <p>
          	Getting a resource representation conforming to a specific profile is done
		by issuing an <code>HTTP GET</code> request against the resource
		and specifying the desired profile URI in an <code>Accept-Profile</code> header.
          	It is possible to specify a range of acceptable profile URIs
		and also to indicate preferences by using quality indicators (q-values).
        </p>
        <pre id="eg-get-http" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Requesting a resource representation conforming to a specific profile using HTTP headers">
GET /resource/a HTTP/1.1
Accept: text/turtle;q=0.8, application/xml;q=0.5
Accept-Profile: urn:example:profile:x;q=1.0,urn:example:profile:y;q=0.6
[more request headers]

---

HTTP/1.1 200 OK
Content-Type: text/turtle
Content-Profile: &lt;urn:example:profile:x>
[more response headers]
        </pre>
        <p>
          Having performed content negotiation and returned a resource representation, it is RECOMMENDED
          that the server also include a Link header indicating the availability of alternate resources
          encoded in other media types and conforming to other profiles, as described above.
        </p>
      </section>
    </section>
    <section id="qsa">
      <h3>URL Query String Arguments</h3>
      <section id="qsa-description">
        <h4>QSA Realization description</h4>
        <div class="issue" data-number="538"></div>
        <p>
          While the HTTP Realization's approach to profile negotiation enables fully automated content negotiation by
          profile, the motivating use cases for this specification included human actionable negotiation. Also, as related
          in <a href="#relatedwork"></a>, previous and existing systems already allow for human-actionable content
          negotiation by profile by a number of means.
        </p>
        <p>
          To both allow for human-actionable content negotiation by profile and also to show how mechanics similar to
          existing systems might fulfill all aspects of this specification's Abstract Model, here we present a Query
          String Argument (QSA) Realization of the Abstract Model. This Realization is functionally equivalent to the
          HTTP Realization in that all required functions of the Abstract Model are supported however it is not mutually
          exclusive of the HTTP, or any other, Realization: a server may implement multiple Realizations in parallel as
          long as each Realization fully supports the Abstract Model.
        </p>
        <p>
          Unlike the HTTP-header Realization which is also the subject of an independent IETF document [[PROF-IETF]],
          this QSA Realization is fully specified here. Two forms of this QSA approach are presented too: the first is the
          fixed keyword "QSA Realization" and the second is the "QSA Alternate Keywords Realization" according to which
          servers may implement any keywords they choose. These two forms, the Abstract Model and the HTTP Realization are
          all identified in <a href="#conformance-profiles"></a>.
          <!-- #text commented out pending Appendix profile description work#
          Conformance of a server to any one or multiple of
          these <a>profiles</a> of this <a>specification</a> may be demonstrated as per
          <a href="#conformancetoprofiles"></a>. Note that it is not required that a server indicates conformance to one
          or more profiles of this specification since not all servers will have the ability to either produce information
          as per <a href="#conformancetoprofiles"></a> and may be described in that way elsewhere (e.g. a
          services catalogue).
          -->
        </p>
        <section id="qsa-uri">
          <h5>QSA URI description</h5>
          <p>
            A query string is a part of a URL which assigns values to specified parameters. QSAs are commonly used within
            web browsers by humans and in other <a>client</a>/<a>server</a> situations to deliver extra information to a
            <em>server</em>. Query string key/value pairs are separated from the scheme, authority and path of a URI by
            a question mark symbol, <code>?</code>, and consist of key/value pairs connected by an equals symbol,
            <code>=</code>, and separated from each other key/value pair by an ampersand symbol, <code>&amp;</code>, as per
            [[RFC3986]].
          </p>
          <p>
            An example URI with profile negotiation by QSA demonstration elements is:
          </p>
          <p>
            <code>http://example.com/path/to/resource/a?<strong>_profile=prof-01</strong>&<strong>_mediatype=text/turtle</strong></code>
          </p>
          <p>
            In the example URI with QSA above, the profile requested for the resource representation is indicated by the
            token <code>prof-01</code> and the Media Type is RDF (turtle) indicated by the
            <a href="http://www.iana.org/assignments/media-types">IANA Media Types list</a> token <code>text/turtle</code>.
            As per <a href="#listprofiles"></a>'s allowance, a <em>token</em> is used here to identify the profile -
            <code>prof-01</code> - but that token MUST be mappable to a URI within one particular client/server session and
            mechanics for that are described below.
          </p>
          <div class="note" title="Maximum length of URLs">
            If Query String Arguments may use URIs (or URLs) to convey important information, implementers should ensure
            that the total length of the total requesting URI within which the QSAs using URIs/URLs exist does not exceed
            length restrictions. [[RFC7230]]'s <a data-cite="RFC7230#section-3.1.1">§3.1.1</a> recommends that senders and
            recipients support request lines of at least 8,000 octets. Some client and server implementations, however,
            cannot accept URLs longer than 2,000 characters, for example, the Sitemap protocol which has a length limit of
            2,048 characters in a URL. Cf.
            <a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers">
            this question on stackoverflow</a> for a longer discussion of issues related to URL length.
          </div>
        </section>
        <section id="qsa-key-naming">
          <h5>Key naming</h5>
          <div class="issue" data-number="511"></div>
          <p>
            This Realization includes two different profiles of this specification that describe two different conformance
            targets which are differentiated by the QSA key naming. The two profiles are the "QSA Realization" and "QSA
            Alternate Keywords Realization" (see <a href="#conformance-profiles"></a>).
          </p>
          <p>
            To conform to the "QSA Realization" profile, the QSA key <code>_profile</code> MUST be used to indicate a
            profile token or URI and <code>_mediatype</code> MUST be used to indicate a resource representation's Media
            Type.
          </p>
          <p>
            When conforming to the profile "QSA Alternate Keywords Realization", any key values to indicate profile and
            Media Type MAY be used, however this profile requires that a mechanism to discover what keys are used MUST be
            supplied and this is detailed below in <a href="#qsa-keydiscovery"></a>.
          </p>
        </section>
        <section id="qsa-token-use">
          <h5>Token and URI use</h5>
          <p>
            Currently, the convention in HTTP content negotiation by Media Type uses tokens for Media Types, such as
            <code>text/html</code> or <code>application/ld+json</code> with the tokens registered at
            <a href="http://www.iana.org/assignments/media-types">IANA's Media Types list</a> and this specification
            indicates that implementers SHOULD use tokens from that list for Media Type identifiers.
          </p>
          <p>
            There is no proposal to create a central register of profiles, as this is thought by these authors to be
            unsustainable in the long term, given the likely numbers of profiles to be established and likely community-
            specific nature of profiles (individual communities will create profiles for their own needs that will not be
            widely relevant).
          </p>
          <p>
            For this reason, the QSA Realizations of this specification allow universally unique and un-registered (no
            central registry) identifiers to be used for profiles. These identifiers MAY be either URIs or tokens. If
            tokens are used, there MUST exist a 1:1 mapping per resource and session between profile tokens and profile
            URIs that is discoverable by clients.
          </p>
          <p>
            Several initiatives exist that have created URIs for Media Types, such as <a href="https://conneg.info">
            conneg.info</a> based on IANA's tokens. As per the URI or token allowance for profiles, these URIs MAY be
            used to indicate Media Types.
          </p>
          <h5>Resource URL</h5>
          <p>
            Resource URLs for which QSA-based profile negotiation is taking place SHOULD NOT themselves be QSA values
            of other resource URIs in any QSA-based realization. Such mechanics may be used internally and are used by
            legacy systems for profile negotiation but are best hidden from to the <em>client</em> applications to make
            conformance to these QSA profiles more recognizable. <a href="#eg-resource-url"></a> shows this.
          </p>
          <pre id="eg-resource-url"
           class="example nohighlight" aria-busy="false" aria-live="polite"
           title="Resource URLs must not, themselves, be parameters of other URLs">
For the representation of Resource X, according to Profile Y, in Media Type Z:

Rather than:
GET /single/endpoint?resource=http://example.org/resource=X&amp;_profile=Y&amp;_mediatype=Z HTTP/1.1

Use:
GET /resource/X?_profile=Y&amp;_mediatype=Z HTTP/1.1
      </pre>
        </section>
      </section>
      <section id="qsa-listprofiles">
        <h4>list profiles</h4>
        <p>
          For conformance to the "QSA Realization Profile", the <code>_profile</code> QSA key SHOULD be supported by the
          <a>server</a> to allow a <a>client</a> to make a <strong>list profiles</strong> <em>request</em>. For this
          request, the reserved token <code>all</code> SHOULD be used, e.g. <code>_profile=all</code>.
        </p>
        <div class="issue" data-number="589"></div>
        <p>
          For conformance to the "QSA Alternate Keywords Realization", other key/value pairs MAY be used, such as
          <code>_view=alternates</code> but then the implementing server MUST supply a means of discovering that key,
          as per <a href="#qsa-keydiscovery"></a>.
        </p>
        <p>
          The <em>server's</em> <a>response</a> to a <em>list profiles</em> <a>request</a> SHOULD be to present a list
          of all profiles that it supports representations of the resource for and optionally also supported Media Types
          for those representations.
        </p>
        <p>
          The server SHOULD represent the alternate profiles information in the HTTP header of the <em>response</em>, as
          per the HTTP Realization (using a Link header) and it MAY also represent the information in the response body
          in place of the default profile representation of a resource. This body content allowance is to enable humans
          to read alternate profile-conformant representation options for a resource easily in a web browser without
          having to view lower-level HTTP information.
        </p>
        <p>
          Where a server does provide alternate profiles information in an HTTP body, the server MAY allow clients to
          negotiate for particular Media Types of the response by using the same Media Type negotiation method used for
          the <em>get resource by profile</em> function below.
        </p>
        <p>
          An example <em>request</em> for the alternate profile representations of a <em>resource</em> to be delivered
          as HTTP body content as well as HTTP header content in the JSON format could look like
          <a href="#eg-list-profiles-mediatype"></a>
        </p>
        <pre id="eg-list-profiles-mediatype" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Requesting a list of profiles for a resource by QSA in HTML">
GET /resource/a?_profile=all&amp;_mediatype=application/json HTTP/1.1

---

# The response shows that representations of the resource can be delivered according
# to two profiles identified by the tokens <em>profile-x</em> &amp; <em>profile-y</em>
# and that <em>profile-x</em>-conformant representations are available in XML &amp; JSON
# where as <em>profile-y</em>-conformant representations are only available in XML

# The content in the JSON body of the response is equivalent to that of the Link header

# Both the Link header and the JSON body include profile URI/token mappings

HTTP/1.1 200 OK
Content-Type: application/json
Content-Profile: &lt;http://www.w3.org/ns/dx/conneg/profile/qsa>
Link:
  &lt;http://example.org/resource/a?_profile=profile-x&amp;_mediatype=application/json>;
          rel="self"; type="text/html";
          profile="http://otherexample.org/profile/x",
  &lt;http://example.org/resource/a?_profile=profile-x&amp;_mediatype=text/xml>;
          rel="alternate";
          type="text/xml";
          profile="http://otherexample.org/profile/x",
  &lt;http://example.org/resource/a?_profile=profile-y&amp;_mediatype=text/xml>;
          rel="alternate";
          type="text/xml";
          profile="http://otherexample.org/profile/y"

{
    "resource": "http://example.org/resource/a",
    "profiles": [
        {
            "token": "profile-x",
            "uri": "http://otherexample.org/profile/x",
            "media_types": ["application/json", "text/xml"]
        },
        {
            "token": "profile-y",
            "uri": "http://otherexample.org/profile/y",
            "media_types": ["text/xml"]
        }
    ]
}
        </pre>
      </section>
      <section id="qsa-getresourcebyprofile">
        <h4>get resource by profile</h4>
        <p>
          To be conformant with the "QSA Realization" profile of this specification, a <em>server</em> MUST allow
          clients to request resources according to profiles they identify with a <code>_profile</code> query string.
          Since either <a>tokens</a> or URIs may be used to identify a profile, servers MUST accept either. Servers MAY
          accept both encoded and un-encoded URIs but MAY also only accept one or the other.
        </p>
        <p>
          To be conformant with the "QSA Alternate Keywords Realization" profile of this specification, a
          <em>server</em> MUST allow clients to request resources according to profiles they identify with a key of the
          server implementor's choosing but then the server MUST also supply a means of discovering that key, as per
          <a href="#qsa-keydiscovery"></a>.
        </p>
        <p>
          A QSA <em>server</em> implementing <em>get resource by profile</em> SHOULD allow a client to indicate
          profile preferences by allowing ordered profile identifiers in the QSA key/value pair for profiles. For
          example, a client preferring <em>profile-z</em> but also accepting <em>profile-y</em> and <em>profile-x</em>,
          in that preference order, could make a request using comma separation of the profile tokes, such as
          <code>GET /resource/a?_profile=profile-z,profile-y,profile-x</code>.
        </p>
        <p>
          Servers SHOULD support any combination of profile URIs or tokens for this (e.g.
          <code>profile-z,http://example.org/profile/x,profile-y</code>) and SHOULD return resource representations
          according to preference. Servers MUST indicate the profile actually returned by including a
          <code>Content-Profile</code> HTTP header in the response and MAY also indicate the returned profile in other
          ways. Servers SHOULD support escaped URIs and MAY also support un-escaped URIs identifying profiles, or both.
        </p>
        <p>
          A server implementing multiple Media Type formats for its resource representations SHOULD allow a client to
          specify a preference order for them in a similar way.
        </p>
      </section>
      <section id="qsa-keydiscovery">
        <h4>QSA key discovery</h4>
        <p>
          <em>This function is only relevant for servers claiming conformance to the "QSA Alternate Keywords
          Realization" profile of this specification.</em>
        </p>
        <p>
          Servers claiming conformance to the "QSA Alternate Keywords Realization" MUST implement methods to allow
          clients to discover the QSA keys used in place of the "QSA Realization" profile's <code>_profile</code> and
          <code>_mediatype</code> and also the equivalent of the <code>_profile=all</code> key/value combination. This
          allows clients with little knowledge of the server to discover how to create <em>list profile</em> and
          <em>get resource by profile</em> requests.
        </p>
        <p>
          A server responding to any request for a resource for which "QSA Alternate Keywords Realization" is supported
          SHOULD include HTTP headers that indicate alternate profiles and Media Types, as per the HTTP Realization.
          They MAY instead, or in addition, provide HTTP body content indicating the same information. If they do, such
          information SHOULD be present in the default response to a URI request, i.e. in response to a request without
          any QSAs. A series of example requests is given in <a href="#eg-qsa-keydiscovery"></a>.
        </p>
        <!--
          , as implemented by the <a href="https://pypi.org/project/pyldapi/">
          pyLDAPI Python library for Linked Data</a>,
          -->
        <pre id="eg-qsa-keydiscovery" class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Example requests and responses for QSA key discovery">
# A client makes a request for Resource A not knowing if any Content
# Negotiation by Profile is supported. It supplies an Accept-Profile
# header just in case. For extra efficiency, the client could have
# made a HEAD request instead of a GET

GET /resource/a HTTP/1.1
Accept-Profile: http://example.org/profile/x

# The server does not understand the HTTP Get Resource By Profile
# request (doesn't support the HTTP Realization) but is able to
# supply an HTTP Link header indicating alternate profiles. It can be
# seen from the Link header that keys other than _profile &
# _mediatype are in use - view & format - thus this is QSA Alt, not a
# QSA Realization-conformant system

# The resource representations available conform to profile-x & profile-y.
# The profile-y-conformant representation is only available in XML

HTTP/1.1 200 OK
Link:
  &lt;http://example.org/resource/a?view=profile-x>;
          rel="self";
          type="text/html";
          profile="http://otherexample.org/profile/x",
  &lt;http://example.org/resource/a?view=profile-y&amp;format=text/xml>;
          rel="alternate";
          type="text/xml";
          profile="http://otherexample.org/profile/y",

# Note that here the server does not directly indicate the profile served
# (there is no Content-Profile header present) but this can be inferred
# by the link header with rel="self"
        </pre>
        <p>
          While the Link header response above communicates all the information that a <em>list profiles</em> request
          does, it is not visible directly in a web browser. While <a href="#eg-list-profiles-mediatype"></a> shows a
          requests/response pair that include equivalent Link header and HTTP body information listing profiles, the
          latter of which is visible in a browser, it is dependent on a client knowing that the QSA key/value pair
          <code>_profile=all</code> is used to trigger this response as opposed to the server's default resource
          representation.
        </p>
        <p>
          To communicate to a client what QSA key/value pair is used for <em>list profiles</em> when the "QSA Alternate
          Keywords Realization" is conformed to, a server SHOULD...
        </p>
        <div class="note">
          <p>
            Nick: it appears we are dependent on an identifier for the "profile of a resource that lists all others
            profiles". This is analogous in content to the Link header response for <em>list profiles</em> and is exactly
            what the existing QSA systems respond with when asked for <code>?_view=alternates</code> and what is given
            above as <code>?_profile=all</code>. So it's a URI that is equivalent to the QSA Realization profile's token
            of <em>all</em>.
          </p>
          <p>
            If we had such a URI, I would be able to say something like a Link header response should include this to
            indicate how a client can show how to trigger <code>?_profile=all</code> (list profiles):
          </p>
          <pre class="nohighlight">Link:
    &lt;http://example.org/resource/a&gt;;
      rel="self";
      type="text/turtle";
      profile="urn:example:profile:x",
    <strong>&lt;http://example.org/resource/a&gt;;
      rel="alternate";
      type="text/turtle";
      profile="http://example.org/profile/alternates",</strong>
    &lt;http://example.org/resource/a&gt;;
      rel="alternate";
      type="text/turtle";
      profile="urn:example:profile:y",
    &lt;http://example.org/resource/a&gt;;
      rel="alternate";
      type="application/xml";
      profile="urn:example:profile:x",
    &lt;http://example.org/resource/a&gt;;
      rel="alternate";
      type="application/xml";
      profile="urn:example:profile:y",
    &lt;http://example.org/resource/a&gt;;
      rel="alternate";
      type="text/html"
            </pre>
          <p>
            The bolded part of the Link header above is the alternate profile for the resource that lists other profiles
            which we know since the profile identifier is <strong><code>http://example.org/profile/alternates</code>
            </strong> in some format (here <code>text/turtle</code>.
          </p>
        </div>
      </section>
    </section>
  </section>
  <section id="testsuites">
    <h2>Test Suites</h2>
    <p>
      This section includes links to software tools to be used for testing the adherence of implementations to the realizations
      given in this document.
    </p>
    <dl>
      <dt>Apache JMeter</dt>
      <dd>
        <p>
          An <a href="http://jmeter.apache.org/">Apache JMeter</a> implementation of a test suite is maintained at:
          <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite">
            https://github.com/CSIRO-enviro-informatics/prof-conneg-jmeter-test-suite
          </a>
        </p>
      </dd>
    </dl>
    <div class="issue" data-number="385"></div>
  </section>
  <section id="implementations" class="informative">
    <h2>Implementations</h2>
    <p>
      This section includes implementations of the realizations given in this document and their conformance test results. The tools
      used for conformance testing are listed in the section above.
    </p>
    <ul>
      <li>
        <a href="https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results">
          https://github.com/CSIRO-enviro-informatics/prof-conneg-conf-test-results
        </a>
      </li>
    </ul>
    <div class="issue" data-number="467"></div>
  </section>
  <section id="acknowledgements" class="informative">
    <h2>Acknowledgements</h2>
    <p>
      The editors gratefully acknowledge the contributions made to this document by all members of the Dataset Exchange
      Working Group, especially Annette Greiner.
    </p>
    <p>
      The editors would also like to thank the following non-Working Group people for supplying comments which were
      used to improve this document: Erik Wilde, Gregg Kellogg &amp; Irene Polikoff.
    </p>
    <p>
      Special thanks must be given to Kam Hay Fung for his most extensive comments and suggestions which found and
      fixed issues for us.
    </p>
    <p>
      Finally, the editors thank the chairs of the Dataset Exchange Working Group: Peter Winstanley &amp; Karen Coyle.
    </p>
  </section>
  <section id="changes" class="informative">
	  <h2>Changes</h2>
	  <p>Changes since the <a href="https://www.w3.org/TR/2018/WD-dx-prof-conneg-20181218/">18 December 2018 Working Draft</a> are:</p>
	  <ul>
    <li>
      Added Related Work subsections for
      Linked Data APIs (<a href="https://github.com/w3c/dxwg/issues/383">Issue 383</a>),
      OAI-PMH (<a href="https://github.com/w3c/dxwg/issues/516">Issue 516</a>),
      &amp; CSW (<a href="https://github.com/w3c/dxwg/issues/882">Issue 882</a>).
    </li>
		<li>Added text about existing standards for transporting profile information in http headers
			to <a href="#relatedwork">related work</a>.
			(<a href="https://github.com/w3c/dxwg/issues/45">Issue 45</a>)</li>
		<li>Removed advice on use of HTTP OPTIONS.
			(<a href="https://github.com/w3c/dxwg/issues/510">Issue 510</a>)</li>
		<li>Added text about ARK identifiers to <a href="#relatedwork">related work</a>.
			(<a href="https://github.com/w3c/dxwg/issues/514">Issue 514</a>)</li>
		<li>Clarified difference between the <code>profile</code> parameter in <code>Accept</code> header fields
			and the <code>Accept-Profile</code> header field.
			(<a href="https://github.com/w3c/dxwg/issues/662">Issue 662</a>)</li>
		<li>Updated the <a href="#security_and_privacy">Security and Privacy</a> section.
			(<a href="https://github.com/w3c/dxwg/issues/782">Issue 782</a>)</li>
		<li>Added a not about length restrictions in URLs to the <a href="#qsa">QSA</a> section.
			(<a href="https://github.com/w3c/dxwg/issues/592">Issue 592</a>)</li>
	</ul>
  </section>
  <section id="security_and_privacy" class="informative">
    <h2>Security and Privacy</h2>
    <p>
      The use of HTTP to negotiate and transport implies that all privacy and security issues
      that are relevant for that protocol are also relevant for profile negotiation. E. g.,
      information such as user agent, accept-headers, IP address etc. can potentially be used as
      identifying information, and particularly, the IP address adds information about geolocation
      and institutional membership.
      Further, offering a list of acceptable profiles at the beginning of a negotiation process
      can reveal information about the user's interests
      that could be used to add such information to a user profile.
    </p>
    <p>
      For a more complete view of those issues, cf. the
      <a href="https://www.w3.org/2017/dxwg/wiki/CnegPrivacyAndSecurityQuestionnaire">Privacy and Security Questionnaire for this deliverable</a>.
    </p>
  </section>
  <section id="appendices" class="appendix">
    <h2>Appendices</h2>
    <section id="requirements">
      <h3>Requirements</h3>
      <p>
        This section lists, and then addresses, individual requirements that the Dataset Exchange Working Group
        considered important for content negotiation by profile.
      </p>
      <div class="note">
        <p>
          Responses to individual requirement Issues listed here are, at the time of the First Public Working Draft of
          this document, for demonstration only; to indicate the logic of answers to individual requirements.
        </p>
        <p>
          These requirement responses may not survive in their current form in later drafts of this document nor may
          individual listings of requirements; they may be subsumed into the flowing txt of the document.
        </p>
      </div>
      <div class="issue" data-number="74"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 74</p>
        <p>
          This requirement is the focus of the IETF RFC in the DXWG Family of Documents [[PROF-IETF]].
        </p>
        <p>
          In summary, a series of new HTTP headers are added to the HTTP specification allowing for HTTP negotiation
          via profile in a manner similar to negotiation via Media Type or Language.
        </p>
      </div>
      <div class="issue" data-number="86"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 86</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="261"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 261</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="265"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 265</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="266"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 266</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="284"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 284</p>
        <p>
          <em>(assuming wording of "a profile must have an identifier")</em>
        </p>
        <p>
          Profiles must be identified by an HTTP URI.
        </p>
        <p>
          Short codes (tokens) for profiles that map to HTTP URIs for them may be used in systems that ensure the
          tokens map deterministically. This allows for the use of simple strings in places where URIs are impractical
          yet preserves the guarantee that every profile has an HTTP URI.
        </p>
      </div>
      <div class="issue" data-number="286"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 286</p>
        <p>

        </p>
      </div>
      <div class="issue" data-number="288"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 288</p>
        <p>
          This requirement is met by [[PROF]].
        </p>
      </div>
      <div class="issue" data-number="289"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 289</p>
        <p>
          This requirement is met by [[PROF-IETF]].
        </p>
      </div>
      <div class="issue" data-number="290"></div>
      <div class="req-response">
        <p class="respTitle">RESPONSE FOR Req. 290</p>
        <p>

        </p>
      </div>
    </section>
    <section id="altr-detail">
      <h3>Alternate Representations Data Model - Details</h3>
      <p>
        <a href="#altr"></a> presents an abstract model, that is, one without implementation in any concrete modelling
        system. This appendix presents both an implementation of this model in OWL [[OWL2-OVERVIEW]] and extensions to
        the model suggested for use in particular scenarios.
      </p>
      <section id="altr-implementations">
        <h4>Implementations</h4>
        <div class="issue" data-number="1041"></div>
        <p>
          A Web Ontology Language [[OWL2-OVERVIEW]] implementation of the data model in <a href="#altr"></a> is given
          below in <a href="#altr-owl">Code Listing 1</a>. It is also available in the file
          <a href="altr.ttl">altr.ttl</a>.
        </p>
        <pre id="altr-owl"
             class="codelisting nohighlight" aria-busy="false" aria-live="polite"
             title="Alternate Profiles Data Model as an OWL ontology">
<div class="codelisting-title">
<a href="#altr-owl">CODE LISTING 1</a>: Alternate Profiles Data Model as an OWL ontology
</div>
@prefix altr: &lt;http://www.w3.org/ns/dx/conneg/altr#> .
@prefix dct: &lt;http://purl.org/dc/terms/> .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#> .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix sdo: &lt;http://schema.org/> .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: &lt;http://www.w3.org/2004/02/skos/core#> .

&lt;http://www.w3.org/ns/dx/conneg/altr>
    a owl:Ontology ;
    rdfs:label "Alternative Profiles Ontology" ;
    rdfs:comment """This ontology allows for the description of representations
                    of Internet resources.

Representations may conform to prof:Profile instances and may have the format
                    of a particular dct:MediaType."""@en ;
    dct:created "2019-08-07"^^xsd:date ;
    dct:modified "2019-08-10"^^xsd:date ;
    dct:creator [
        a sdo:Person ;
        sdo:affiliation [
            sdo:name "SURROUND Australia Pty Ltd" ;
            sdo:url &lt;https://surroundaustralia.com>
        ] ;
        sdo:email &lt;mailto:nicholas.car@surroundaustralia.com> ;
        sdo:identifier &lt;http://orcid.org/0000-0002-8742-7730> ;
        sdo:name "Nicholas J. Car"
    ] .

dct:conformsTo
    a owl:ObjectProperty ;
    rdfs:label "conforms to" ;
    dct:source dct:conformsTo ;
    skos:scopeNote "Use this property to indicate a dct:Standard that a
        altr:Representation conforms to." .

altr:hasRepresentation
    a owl:ObjectProperty ;
    rdfs:label "has representation" ;
    skos:definition "Indicates a Representation of a Resource."@en ;
    rdfs:domain rdf:Resource ;
    rdfs:range altr:Representation ;
    skos:scopeNote "Use this property to indicate a the HTTP-delivered
                    representation of a resource." .

altr:hasDefaultRepresentation
    a owl:ObjectProperty ;
    rdfs:label "has default representation" ;
    skos:definition "Indicates the default Representation of a Resource."@en ;
    rdfs:subPropertyOf altr:hasRepresentation ;
    skos:scopeNote "Use this property to indicate the default HTTP-delivered
                    representation of a resource that is obtained when no
                    further instructions are given to a server to obtain a
                    resource's representation other than the identification
                    (URI) of the resource" .

rdf:Resource
    a owl:Class ;
    rdfs:label "Resource" ;
    skos:definition "The class resource, everything."@en ;
    rdfs:subClassOf [
        a owl:Restriction ;
        owl:onProperty altr:hasRepresentation ;
        owl:allValuesFrom altr:Representation
    ] ;
    dct:source "http://www.w3.org/2000/01/rdf-schema#Resource" ;
    skos:scopeNote "In the context of this mode, rdf:Resource instances are
                    used to identify Internet resources, that is items
                    identified by a URI." .

altr:Representation
    a owl:Class ;
    rdfs:label "Representation" ;
    skos:definition "An abstraction of the current or desired state of a
                     thing in HTTP communications."@en ;
    rdfs:subClassOf [
        a owl:Restriction ;
        owl:onProperty dct:conformsTo ;
        owl:allValuesFrom dct:Standard
    ] ;
    dct:source &lt;https://httpwg.org/specs/rfc7230.html> ;
    rdfs:isDefinedBy &lt;http://www.w3.org/ns/dx/conneg/altr> ;
    skos:scopeNote "Use this class to indicate instances of representations
                    of resources" .

dct:Standard
    a owl:Class ;
    rdfs:label "Standard" ;
    skos:definition "A basis for comparison; a reference point against which
                     other things can be evaluated."@en ;
    dct:source "http://purl.org/dc/terms/Standard" ;
    skos:scopeNote "In the context of this mode, use this class to indicate
                    instances of information models that representations of
                    resources can conform to." .
        </pre>
      </section>
      <section id="altr-extensions">
        <h4>Extensions</h4>
        <div class="note" title="AltP / PROF work requried">
          See the reference to Issue #1041 in the previous subsection for discussion of work needed to relate the
          Alternative Profiles Data Model to the Profiles Vocabulary.
        </div>
        <p>
          The <a href="#altr">Alternate Profiles Data Model</a> may be extended to include additional information of use in
          content negotiation by profile situations. One obviously useful extension is the inclusion of information about
          other dimensions of content negotiation, particularly Media Type. <a href="#altr-ontology-ext-1">Code Listing 2</a>
          includes RDF definitions of Dublin Core Term's [[DCTERMS]] <code>dct:format</code> property and
          <code>dct:MediaType</code> class for Media Type indications that could be added to the Data Model, as
          represented in OWL in <a href="#altr-owl">Code Listing 1</a>. <a href="#eg-altr-ext"></a> gives an example of this
          extended model's use following on from the content in <a href="#eg-altr"></a>.
        </p>
        <pre id="altr-ontology-ext-1"
             class="codelisting nohighlight" aria-busy="false" aria-live="polite"
             title="Alternate Profiles Data Model as an OWL ontology">
<div class="codelisting-title">
<a href="#altr-ontology-ext-1">CODE LISTING 2</a>: Suggested extension to this specification's Alternate Profiles Data Model in OWL to
cater for Media Type representations
</div>
@prefix ex: &lt;http://example.org/altr-ext#> .
@prefix dct: &lt;http://purl.org/dc/terms/> .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#> .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: &lt;http://www.w3.org/2004/02/skos/core#> .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#> .

dct:format
    a owl:ObjectProperty ;
    rdfs:label "format" ;
    skos:definition "The file format, physical medium, or dimensions of the resource."@en ;
    dct:source dct:format ;
    rdfs:range dct:MediaType ;
    skos:scopeNote "Use this property to indicate an IANA Media Type of a resource's
                    representation " .

ex:isProfilesDefault
    a owl:DataTypeProperty ;
    rdfs:label "is profile's default" ;
    skos:definition "Indicates the default Representation for Resource for the specified
                     Standard."@en ;
    rdfs:range xsd:boolean ;
    skos:scopeNote "Use this property to indicate which of more than one resource
                    representations that conforms to a profile is the default for get
                    resource by profile requests." .

dct:MediaType
    a owl:Class ;
    rdfs:label "Media Type" ;
    skos:definition "A file format or physical medium."@en ;
    dct:source "http://purl.org/dc/terms/MediaType" ;
    skos:scopeNote "In the context of this mode, use this class to indicate
                    the IANA Media Type of a resource's representation." .
        </pre>
        <pre id="eg-altr-ext"
           class="example nohighlight" aria-busy="false" aria-live="polite"
           title="Extended implementation of the Alternative Profiles data model in RDF (turtle) showing Media Type information">
@prefix altr: &lt;http://www.w3.org/ns/dx/conneg/altr#> .
@prefix dct: &lt;http://purl.org/dc/terms/> .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#> .

# This Resource A has 5 Representations, the 3rd of which is the default.
# Some of the Representations conform to the same Standard but are formatted
# according to different Media Types. Some Representations contain no Media
# Type information.
&lt;http://example.org/resource/a>
    a rdf:Resource ;
    rdfs:label "Resources A" ;
    altr:hasRepresentation :rep-1 , :rep-2 , :rep-3 , :rep-4 , :rep-5 ;
    altr:hasDefaultRepresentation :rep-3 .

:rep-1
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/x> ;
    dct:format "application/xml" .

:rep-2
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/y> .

# This representation is the default for the set of representations
# that conform to &lt;http://otherexample.org/profile/z>
:rep-3
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/z> .
    dct:format "text/html" ;
    ex:isProfilesDefault "true" .

:rep-4
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/z> ;
    dct:format "text/turtle" .

:rep-5
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/z> ;
    dct:format "application/ld+json" .
  </pre>
      </section>
      <section>
        <h4>Examples of model use</h4>
        <p>
          An example instance of RDF data created conforming to the OWL implementation of the Alternative Profiles Data
          Model <a href="#eg-altr"></a> followed by the same content shown in multiple formats in
          <a href="#eg-altr-multi"></a>.
        </p>
        <pre id="eg-altr"
             class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Implementation of the Alternative Profiles Data Model in RDF (turtle)">
@prefix altr: &lt;http://www.w3.org/ns/dx/conneg/altr#> .
@prefix dct: &lt;http://purl.org/dc/terms/> .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#> .

# This Resource A has 3 Representations, the 3rd of which is the default
&lt;http://example.org/resource/a>
    a rdf:Resource ;
    rdfs:label "Resources A" ;
    altr:hasRepresentation :rep-1 , :rep-2 , :rep-3 ;
    altr:hasDefaultRepresentation :rep-3 .

# Each Representation and the Standard each conforms to, X, Y & Z
:rep-1
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/x> .

:rep-2
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/y> .

:rep-3
    a altr:Representation ;
    dct:conformsTo &lt;http://otherexample.org/profile/z> .
      </pre>
        <pre id="eg-altr-multi"
             class="example nohighlight" aria-busy="false" aria-live="polite"
             title="Multiple format implementation of the previous example's content">
# The content of the previous example expressed as in an HTTP Link header
# as per the HTTP Application Profile of this Specification with the
# default Representation indicated by the use of rel="self". Note the
# Representations are seen, one per Link result comma-separated, identified
# only by the combination of the Resource URI, the URI of the Standard to
# which they conform and the rel attribute - they do not have individual
# identifiers
Link:
  &lt;http://example.org/resource/a>;
          rel="alternate";
          profile="http://otherexample.org/profile/x",
  &lt;http://example.org/resource/a>;
          rel="alternate";
          profile="http://otherexample.org/profile/y",
  &lt;http://example.org/resource/a>;
          rel="self";
          profile="http://otherexample.org/profile/z"

---

# The content of the previous example expressed as in table form
# such as could potentially be expressed in the HTML body of an HTTP
# response. The Resource URIs include Query String Arguments that,
# when specified, allow the individual Representations to be returned,
# as per the QSA Application Profile below.
---------------------------------------------------------------------------------------
| Shortened Resource URI                | URI of profile conformed to       | Default |
---------------------------------------------------------------------------------------
| http://.../resource/a?_profile=prof-x | http://otherexample.org/profile/x |         |
| http://.../resource/a?_profile=prof-y | http://otherexample.org/profile/y |         |
| http://.../resource/a?_profile=prof-z | http://otherexample.org/profile/z | Yes     |
---------------------------------------------------------------------------------------
        </pre>
      </section>
    </section>
    <section id="issue-summary" class="appendix">
      <h3>Issue Summary</h3>
      <!-- A list of issues will magically appear here -->
    </section>
    <section id="extra-issues" class="appendix">
      <h3>Additional Issues</h3>
      <p><em>This section will be removed in a later version of this document.</em></p>
      <p>Additional Issues related to this document and not yet placed within it are listed at the:</p>
      <ul>
        <li><a href="https://github.com/w3c/dxwg/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3Aprofile-negotiation+sort%3Acreated-asc+">GitHub Issues tracker for profile-negotiation</a></li>
      </ul>
    </section>
  </section>
  <script class="remove" src="config.js"></script>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
</body>
</html>
